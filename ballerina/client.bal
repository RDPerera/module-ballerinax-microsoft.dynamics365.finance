// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;

# Microsoft Dynamics 365 Finance and Operations OData REST API for data entities including customers, vendors, products, and financial data.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://your-org.cloud.onebox.dynamics.com/data") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get Customers V3 - Field List Cross Company GBSI USSI
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getCustomersV3FieldListCrossCompanyGbsiUssi(map<string|string[]> headers = {}, *GetCustomersV3FieldListCrossCompanyGbsiUssiQueries queries) returns CustomersV3Collection|error {
        string resourcePath = string `/CustomersV3`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Customer V3
    #
    # + headers - Headers to be sent with the request 
    # + return - Customer created successfully 
    remote isolated function postCustomersV3(CustomerV3 payload, map<string|string[]> headers = {}) returns CustomerV3|error {
        string resourcePath = string `/CustomersV3`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Customers V3 Cross Company Count
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Count of customers 
    remote isolated function getCustomersV3CrossCompanyCount(map<string|string[]> headers = {}, *GetCustomersV3CrossCompanyCountQueries queries) returns string|error {
        string resourcePath = string `/CustomersV3/$count`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update Customer V3
    #
    # + headers - Headers to be sent with the request 
    # + return - Customer updated successfully 
    remote isolated function updateCustomersV3(string dataAreaId, string customerAccount, CustomerV3 payload, map<string|string[]> headers = {}) returns CustomerV3|error {
        string resourcePath = string `/CustomersV3(dataAreaId='${getEncodedUri(dataAreaId)}',CustomerAccount='${getEncodedUri(customerAccount)}')`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Get Vendors V2 Cross Company All
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getVendorsV2CrossCompanyAll(map<string|string[]> headers = {}, *GetVendorsV2CrossCompanyAllQueries queries) returns VendorsV2Collection|error {
        string resourcePath = string `/VendorsV2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Vendors V2 Cross Company Count
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Count of vendors 
    remote isolated function getVendorsV2CrossCompanyCount(map<string|string[]> headers = {}, *GetVendorsV2CrossCompanyCountQueries queries) returns string|error {
        string resourcePath = string `/VendorsV2/$count`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Released Products Field List Cross Company
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getReleasedProductsFieldListCrossCompanyJ00029(map<string|string[]> headers = {}, *GetReleasedProductsFieldListCrossCompanyJ00029Queries queries) returns ReleasedProductsV2Collection|error {
        string resourcePath = string `/ReleasedProductsV2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Released Products Cross Company Count
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Count of released products 
    remote isolated function getReleasedProductsCrossCompanyCount(map<string|string[]> headers = {}, *GetReleasedProductsCrossCompanyCountQueries queries) returns string|error {
        string resourcePath = string `/ReleasedProductsV2/$count`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Customer Groups Cross Company
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getCustomerGroupsCrossCompany(map<string|string[]> headers = {}, *GetCustomerGroupsCrossCompanyQueries queries) returns CustomerGroupsCollection|error {
        string resourcePath = string `/CustomerGroups`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Exchange Rates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getExchangeRatesRateType01092023(map<string|string[]> headers = {}, *GetExchangeRatesRateType01092023Queries queries) returns ExchangeRatesCollection|error {
        string resourcePath = string `/ExchangeRates`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get System Users
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getSystemUsers(map<string|string[]> headers = {}) returns SystemUsersCollection|error {
        string resourcePath = string `/SystemUsers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create System User
    #
    # + headers - Headers to be sent with the request 
    # + return - User created successfully 
    remote isolated function postSystemUsers(SystemUser payload, map<string|string[]> headers = {}) returns SystemUser|error {
        string resourcePath = string `/SystemUsers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get OData Service Root
    #
    # + headers - Headers to be sent with the request 
    # + return - Service root with available entity sets 
    remote isolated function getData(map<string|string[]> headers = {}) returns inline_response_200|error {
        string resourcePath = string `/data`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get OData Metadata
    #
    # + headers - Headers to be sent with the request 
    # + return - OData metadata document 
    remote isolated function getMetadataAnnotations(map<string|string[]> headers = {}) returns xml|error {
        string resourcePath = string `/$metadata`;
        return self.clientEp->get(resourcePath, headers);
    }
}
